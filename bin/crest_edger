#!/usr/bin/env Rscript

# crest_edger FIN_NAME=\"data/data.txt\" TREAT_ID=\"T1,T2,T3,T4,T5\" CONTROL_ID=\"C1,C2\" MIN_CPM=5
 
INQURE_REGION=\'chr6:30132134-32138339\' GROUPS="c(2,2,2,2,2,1,1)"  FOUT_NAME=\"TMP\" MIN_CPM=5 BIN_SIZE=50

# PART I - ARGUMENTS
args <- commandArgs(trailingOnly = TRUE)
if(length(args) < 6){
    stop("too few arguments.")
}else{
    for(i in 1:length(args)){
		invisible(eval(parse(text=args[[i]])))
    }
}

if(!exists("FIN_NAME")) stop("argument FIN_NAME missing")
if(!exists("TREAT_ID")) stop("argument TREAT_ID missing")
if(!exists("CONTROL_ID")) stop("argument CONTROL_ID missing")


#if(!exists("MIN_CPM")) stop("argument MIN_CPM missing")
#if(!exists("BIN_SIZE")) stop("argument BIN_SIZE missing")
#if(!exists("INQURE_REGION")) stop("argument INQURE_REGION missing")
#if(!exists("FOUT_NAME")) stop("argument FOUT_NAME missing")
#if(!exists("GROUPS")) stop("argument GROUPS missing")
#if(!file.exists(FIN_NAME)) stop("file FIN_NAME not exists")

# PART II - check if packages exists, if not, install
list.of.packages <- c("edgeR", "GenomicRanges")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){
	source("http://bioconductor.org/biocLite.R")
	biocLite(new.packages, lib.loc = "~/R/local_library", lib="~/R/local_library")
}

list.of.packages <- c("locfit", "stringr")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)){
	install.packages(new.packages, lib.loc = "~/R/local_library", lib="~/R/local_library")
}


suppressMessages(library(edgeR))
suppressMessages(library(GenomicRanges))
#suppressMessages(library(locfit))
#suppressMessages(library(stringr))

if(nrow(data <- read.table(FIN_NAME, head=TRUE, row.names=1))==0) stop("input crest matrix is empty")
if(length((TREAT_IDs=strsplit(TREAT_ID, ",")[[1]]))==0) stop("argument TREAT_ID must be seperated by comma without space")
if(length((CONTROL_IDs=strsplit(CONTROL_ID, ",")[[1]]))==0) stop("argument CONTROL_ID must be seperated by comma without space")
if(length((IDs = c(TREAT_IDs, CONTROL_IDs))) != ncol(data)) stop("TREAT_ID + CONTROL_ID must equal column number with input crest matrix")
if(length((col_pos = match(TREAT_IDs, colnames(data)))) == 0) stop("argument TREAT_ID must match with column name of input crest-matrix")
if(length((col_neg = match(CONTROL_IDs, colnames(data)))) == 0) stop("argument CONTROL_ID must match with column name of input crest-matrix")

groups = rep(1, ncol(data))
groups[col_pos] = 2

if(length(i <- which(rowSums(cpm(data) > MIN_CPM) >= (ncol(data)/3)))) data_filtered <- data[i,]



if(length(str_extract_all(INQURE_REGION, perl("chr[0-9a-zA-Z_]*:[0-9]+-[0-9]+"))[[1]])==0) stop("argument INQURE_REGION not in chr1:10000-20000 format")
if(ncol(data) != length(GROUPS)) stop("argument GROUPS does not match with input data")

# interprate input parameter
inqure_cord <- as.data.frame(do.call(rbind, strsplit(INQURE_REGION, ":|-")))
inqure_chrom <- as.character(inqure_cord[1,1])
inqure_start <- as.numeric(as.character(inqure_cord[1,2]))
inqure_end <- as.numeric(as.character(inqure_cord[1,3]))

label_neg = label_pos = NULL
if(length(i <- grep("POS", rownames(data)))) label_pos = i
if(length(i <- grep("NEG", rownames(data)))) label_neg = i
label_use <- setdiff(1:nrow(data), c(label_pos, label_neg))
X = list(counts=data, pos=label_pos, neg=label_neg, use=label_use)

# Need a CPM (count per million) greater than MIN_CPM in at least 1/3 of the samples
if(length(i <- which(rowSums(cpm(X$counts) > MIN_CPM) >= (ncol(X$counts)/3)))) X$use <- intersect(X$use, i)

## sort sgRNA pairs
y <- DGEList(X$counts[X$use,], group=GROUPS)
design <- model.matrix(~GROUPS)
xglm <- estimateDisp(y, design)
fit <- glmFit(xglm, design)
lrt <- glmLRT(fit, coef=2)
sgRNA <- lrt$table
sgRNA$score <- sign(sgRNA$logFC) * (log(sgRNA$PValue))
sgRNA <- sgRNA[order(sgRNA$score),]
sgRNA$rank <- 1:nrow(sgRNA)
sgRNA <- sgRNA[order(rownames(sgRNA)),]
#
#
## generate sgRNA.gr
cooridnates <- as.data.frame(do.call(rbind, strsplit(as.character(rownames(sgRNA)), ":|-")))
sgRNA <- cbind(cooridnates, sgRNA)
sgRNA.gr <- GRanges(seqnames = sgRNA[,1], ranges = IRanges(as.numeric(as.character(sgRNA[,2])), as.numeric(as.character(sgRNA[,3]))), score=sgRNA$score)

# split given inqure region into bin
tmp = seq(inqure_start, inqure_end, by=BIN_SIZE)
bins.gr <- GRanges(seqnames = inqure_chrom, ranges = IRanges(tmp, end = tmp+BIN_SIZE))
bins.gr$name <- paste(paste(inqure_chrom, tmp, sep=":"), tmp+BIN_SIZE, sep="-")

# overlap
ov <- as.data.frame(findOverlaps(bins.gr, sgRNA.gr, type="within"))
res <- data.frame(bin=bins.gr$name[ov$queryHits], score=sgRNA.gr$score[ov$subjectHits], subjectHits=ov$subjectHits)
res <- res[order(res$subjectHits),]

res$rank = 1:nrow(res)
index <- do.call(rbind, lapply(split(res[,c(3,4)], res$subjectHits), function(x) x[1,]))
res$chosen = 0
res$chosen[index$rank] = 1

res.high <- data.frame(sgrna=1:nrow(res), symbol=res$bin, pool="list", p.high=res$score, prob=1, chosen=res$chosen)

write.table(res.high, file = FOUT_NAME, append = FALSE, quote = FALSE, sep = "\t",
            eol = "\n", na = "NA", dec = ".", row.names = FALSE,
            col.names = TRUE, qmethod = c("escape", "double"),
            fileEncoding = "")

